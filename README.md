# RustMacroLearn
Rustのマクロを学びます


# マクロとは

Rustにおいては、**ある機能の集合**を指す。
また、マクロには以下のジャンルがある

- 宣言的 (declarative) マクロ
- 手続き的 (procedural) マクロ
    - 構造体とenumにderive属性を使ったときに追加されるコードを指定する、カスタムの#[derive]マクロ
    - 任意の要素に使えるカスタムの属性を定義する、属性風のマクロ
    - 関数のように見えるが、引数として指定されたトークンに対して作用する関数風のマクロ

## マクロと関数の違い
基本的に、マクロは他のコードを記述するコードを書く術であり、メタプログラミングとして知られている
例えば、`println!`と`vec!`のマクロを使用したら、
これらは全て展開され、手で書いたよりも多くのコードを生成するわけだが、
これは書いて管理しないといけないコード量を減らすのに有用で
これは関数の役目の一つでもあるが、マクロには、これに加えて、
関数と違って、マクロは可変長引数を取れる。
また、コンパイラがコードの意味を解釈する（コンパイル）前に展開されるため、与えられた型にTraitを実装できる。これは関数にはできない。関数はあくまで実行時に呼ばれ、トレイトはコンパイル時に実装される必要があるから

マクロを実装する欠点は、Rustコードを記述するRustコードを書いているので、 関数定義よりもマクロ定義は複雑になること。そのため、
マクロ定義は一般的に、 関数定義よりも、読みにくく、わかりにくく、管理しづらい。

また、ファイル内で呼び出す前にマクロは定義したりスコープに導入しなければなりませんが、 一方で関数はどこにでも定義でき、どこでも呼び出せます。

### 宣言的マクロ
最も利用される形態のマクロがこれ
`macro_rules!`マクロとも言われる。
これは、`match`式に似た何かを書ける。
あるコードと紐付けられたパターンと、マクロに渡されたリテラルのRustのソースコードを比較し、パターンがそのソースコードの構造と比較され 各パターンに紐づいたコードは、それがマッチしたときに、マクロに渡されたコードを置き換えます。これは全て、コンパイル時に起きます。

定義するには、`macro_rules!`構文を使用する。

例えば、`vec!`というマクロがある。
```rust
let v: Vec<u32> = vec![1, 2, 3];
```

このマクロを簡略化して再現したものがこちらです。
```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

これにおける、`#[macro_export]`は、
マクロを定義しているクレートがスコープに持ち込まれたなら、
このマクロは即座に利用可能になるべきということを示す。

また、マクロ名の`!`は自動的に付与される。
マクロの定義文は以下の要素で構成されています。

- パターン：`( $( $x:expr ),* )`
- アーム：`=>`
- パターンに紐づくコードブロック：` => { {展開されるプログラム} }`

パターンが合致すれば、紐づいたコードのブロックが発される。
これがこのマクロの唯一のパターン。

合致するパターンは一つだけ定義可能で、
それ以外は全てエラー。

より複雑なマクロには2つ以上のアームがある

[マクロ定義のパターン記法](https://doc.rust-lang.org/reference/macros.html)は、値ではなく、コードの構造に対するマッチを行っている。

`( $( $x:expr ),* )`が何を示しているかというと、
1. まず`()`でパターン全体が囲まれている
2. `$()`で置き換え対象のコードを指定
3. `$x:expr`で任意のRust式に対して、`$x`という名前を与えるとする
4. `*`はパターンが`*`の前にあるもの0個以上にマッチすることを指定

ブロックの中には、`$()*`に囲まれたコードがあるので、
マッチした回数に応じて、0回以上パターン内で`$()`にマッチする箇所ごとに生成。
また、`$x`はマッチした式に置き換えられる。

### 手続的マクロ

これはより関数のように働く。
コードを入力として受け取り、そのコードに対して作用して、出力としてコードを生成する
3種の手続的マクロは皆同じような挙動をする
手続き的マクロを作る際は、その定義はそれ専用の特殊なクレート内に置かれる必要がある。

```rust
#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {}
```

手続的マクロは、TokenStreamを入力として受け取り、TokenStreamを出力として受けとる。
TokenStream型はRustに内蔵されているproc_macroクレートで定義されており、トークンの列を表します。
ここがマクロの一番重要なところなのですが、マクロが作用するソースコードは、入力のTokenStreamへと変換され、マクロが生成するコードが出力のTokenStreamなのです。
この関数には属性もつけられていますが、これはどの種類の手続き的マクロを作っているのかを指定します。 同じクレート内に複数の種類の手続き的マクロを持つことも可能です。

様々な種類の手続き的マクロを見てみましょう。カスタムのderiveマクロから始めて、そのあと他の種類との小さな相違点を説明します。

#### カスタムの`derive`マクロ

hello_macroという名前のクレートを作成してみましょう。 このクレートは、hello_macroという関連関数が1つあるHelloMacroというトレイトを定義します。 クレートの使用者に使用者の型にHelloMacroトレイトを実装することを強制するのではなく、 使用者が型を#[derive(HelloMacro)]で注釈してhello_macro関数の既定の実装を得られるように、 手続き的マクロを提供します。既定の実装は、Hello, Macro! My name is TypeName!(訳注: こんにちは、マクロ！僕の名前はTypeNameだよ！)と出力し、 ここでTypeNameはこのトレイトが定義されている型の名前です。言い換えると、他のプログラマに我々のクレートを使用して、 リスト19-30のようなコードを書けるようにするクレートを記述します。

```rust
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```

そのために、
```sh
cargo new hello_macro --lib
```
を作成し、その`lib.rs`に
```
pub trait HelloMacro {
    fn hello_macro();
}
```
と実装して、Traitと関数を作成すると、
```rust
use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Hello, Macro! My name is Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}
```

とできるのですが、
できれば、使用したい型それぞれに実装ブロックを書かなくても良いようにしたい。
また、まだ`hello_macro`関数にトレイトが実装されている型の名前を出力する既定の実装を提供することはできない状態になっている。Rustにはリフレクションの能力がないので、型の名前を実行時に検索することができないのです。 コンパイル時にコード生成するマクロが必要。

注釈: リフレクションとは、実行時に型名や関数の中身などを取得する機能のことです。 言語によって提供されていたりいなかったりしますが、実行時にメタデータがないと取得できないので、 RustやC++のようなアセンブリコードに翻訳され、パフォーマンスを要求される高級言語では、提供されないのが一般的と思われます。

そのため、手続的マクロを定義することです。
手続的マクロは独自のクレートと存在する必要がある。
クレートとマクロクレートを構成する慣習は、
`foo`というクレートに対して、カスタムのderive手続き的マクロクレートは`foo_derive`
と呼ばれる。
`hello_macro`プロジェクト内に、 `hello_macro_derive`と呼ばれる新しいクレートを開始

```sh
cargo new hello_macro_derive --lib
```

2つのクレートは密接に関係しているので、
`hello_macro`クレートのディレクトリ内に手続き的マクロクレートを作成しています。 `hello_macro`のトレイト定義を変更したら、`hello_macro_derive`の手続き的マクロの実装も変更しなければならない。
 2つのクレートは個別に公開される必要があり、これらのクレートを使用するプログラマは、 両方を依存に追加し、スコープに導入する必要があるでしょう。`hello_macro`クレートに依存として、 `hello_macro_derive`を使用させ、手続き的マクロのコードを再エクスポートすることもできるかもしれませんが、 このようなプロジェクトの構造にすることで、プログラマが`derive`機能を使用したくなくても、`hello_macro`を使用することが可能

`hello_macro_derive`クレートを手続き的マクロクレートとして宣言する必要があります。 また、すぐにわかるように、`syn`と`quote`クレートの機能も必要になるので、依存として追加する必要があります。 以下を`hello_macro_derive`のCargo.tomlファイルに追加してください:

```toml
[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"
```

手続き的マクロの定義を開始するために、hello_macro_deriveクレートのsrc/lib.rsファイルにリスト19-31のコードを配置してください。 impl_hello_macro関数の定義を追加するまでこのコードはコンパイルできないことに注意

```rust
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // 操作可能な構文木としてのRustコードの表現を構築する
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // トレイトの実装内容を構築
    // Build the trait implementation
    impl_hello_macro(&ast)
}
```

#### 属性風マクロ

#### 関数風マクロ

