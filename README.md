# RustMacroLearn
Rustのマクロを学びます


# マクロとは

Rustにおいては、**ある機能の集合**を指す。
また、マクロには以下のジャンルがある

- 宣言的 (declarative) マクロ
- 手続き的 (procedural) マクロ
    - 構造体とenumにderive属性を使ったときに追加されるコードを指定する、カスタムの#[derive]マクロ
    - 任意の要素に使えるカスタムの属性を定義する、属性風のマクロ
    - 関数のように見えるが、引数として指定されたトークンに対して作用する関数風のマクロ

## マクロと関数の違い
基本的に、マクロは他のコードを記述するコードを書く術であり、メタプログラミングとして知られている
例えば、`println!`と`vec!`のマクロを使用したら、
これらは全て展開され、手で書いたよりも多くのコードを生成するわけだが、
これは書いて管理しないといけないコード量を減らすのに有用で
これは関数の役目の一つでもあるが、マクロには、これに加えて、
関数と違って、マクロは可変長引数を取れる。
また、コンパイラがコードの意味を解釈する（コンパイル）前に展開されるため、与えられた型にTraitを実装できる。これは関数にはできない。関数はあくまで実行時に呼ばれ、トレイトはコンパイル時に実装される必要があるから

マクロを実装する欠点は、Rustコードを記述するRustコードを書いているので、 関数定義よりもマクロ定義は複雑になること。そのため、
マクロ定義は一般的に、 関数定義よりも、読みにくく、わかりにくく、管理しづらい。

また、ファイル内で呼び出す前にマクロは定義したりスコープに導入しなければなりませんが、 一方で関数はどこにでも定義でき、どこでも呼び出せます。

### 宣言的マクロ
最も利用される形態のマクロがこれ
`macro_rules!`マクロとも言われる。
これは、`match`式に似た何かを書ける。
あるコードと紐付けられたパターンと、マクロに渡されたリテラルのRustのソースコードを比較し、パターンがそのソースコードの構造と比較され 各パターンに紐づいたコードは、それがマッチしたときに、マクロに渡されたコードを置き換えます。これは全て、コンパイル時に起きます。

定義するには、`macro_rules!`構文を使用する。

例えば、`vec!`というマクロがある。
```rust
let v: Vec<u32> = vec![1, 2, 3];
```

このマクロを簡略化して再現したものがこちらです。
```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

これにおける、`#[macro_export]`は、
マクロを定義しているクレートがスコープに持ち込まれたなら、
このマクロは即座に利用可能になるべきということを示す。

また、マクロ名の`!`は自動的に付与される。
マクロの定義文は以下の要素で構成されています。

- パターン：`( $( $x:expr ),* )`
- アーム：`=>`
- パターンに紐づくコードブロック：` => { {展開されるプログラム} }`

パターンが合致すれば、紐づいたコードのブロックが発される。
これがこのマクロの唯一のパターン。

合致するパターンは一つだけ定義可能で、
それ以外は全てエラー。

より複雑なマクロには2つ以上のアームがある

[マクロ定義のパターン記法](https://doc.rust-lang.org/reference/macros.html)は、値ではなく、コードの構造に対するマッチを行っている。

`( $( $x:expr ),* )`が何を示しているかというと、
1. まず`()`でパターン全体が囲まれている
2. `$()`で置き換え対象のコードを指定
3. `$x:expr`で任意のRust式に対して、`$x`という名前を与えるとする
4. `*`はパターンが`*`の前にあるもの0個以上にマッチすることを指定

ブロックの中には、`$()*`に囲まれたコードがあるので、
マッチした回数に応じて、0回以上パターン内で`$()`にマッチする箇所ごとに生成。
また、`$x`はマッチした式に置き換えられる。

### 手続的マクロ

これはより関数のように働く。
コードを入力として受け取り、そのコードに対して作用して、出力としてコードを生成する
3種の手続的マクロは皆同じような挙動をする
手続き的マクロを作る際は、その定義はそれ専用の特殊なクレート内に置かれる必要がある。

```rust
#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {}
```

手続的マクロは、TokenStreamを入力として受け取り、TokenStreamを出力として受けとる。
TokenStream型はRustに内蔵されているproc_macroクレートで定義されており、トークンの列を表します。
ここがマクロの一番重要なところなのですが、マクロが作用するソースコードは、入力のTokenStreamへと変換され、マクロが生成するコードが出力のTokenStreamなのです。
この関数には属性もつけられていますが、これはどの種類の手続き的マクロを作っているのかを指定します。 同じクレート内に複数の種類の手続き的マクロを持つことも可能です。

様々な種類の手続き的マクロを見てみましょう。カスタムのderiveマクロから始めて、そのあと他の種類との小さな相違点を説明します。

#### カスタムの`derive`マクロ

#### 属性風マクロ

#### 関数風マクロ

